<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Text Detection and Recognition</title>
    <script async src="opencv.js" type="text/javascript"></script>
    <script src="tesseract.js"></script>
</head>
<body>
<h2>Text Detection and Recognition</h2>

<div>
    <img id="imageSrc" alt="No Image" style="display:none;" />
    <input type="file" id="fileInput" name="file" />
    <input type="button" onclick="reset()" value="reset">
    <canvas id="canvasOutput"></canvas>
    <canvas id="canvasoutputrect"></canvas>
    <button id="showRectanglesButton">Show Rectangles</button>
</div>
<p id = "detectedText" style="font-size: 20px;">Text</p>
<script type="text/javascript">
let imgElement = document.getElementById("imageSrc");
let inputElement = document.getElementById("fileInput");
let canvas = document.getElementById("canvasOutput");
let ctx = canvas.getContext('2d');
let points = [];
const maxPoints = 4;
let originalImageData = null; // To store the original image data for OpenCV processing

inputElement.addEventListener("change", (e) => {
    imgElement.src = URL.createObjectURL(e.target.files[0]);
    imgElement.onload = function() {
        // Set canvas dimensions and draw the original image
        canvas.width = imgElement.naturalWidth;
        canvas.height = imgElement.naturalHeight;
        ctx.drawImage(imgElement, 0, 0);

        // Store original image data for OpenCV processing
        originalImageData = canvas.toDataURL('image/png');
        
        // Clear points and add event listener for clicks
        points = [
    {
        "x": 0,
        "y": 0
    },
    {
        "x": 0,
        "y": 4000
    },
    {
        "x": 2992,
        "y": 0
    },
    {
        "x": 2992,
        "y": 4000
    }
];
        calculateDimensions(points);
        // Process the original image with OpenCV
        processImage(originalImageData);
    };
}, false);
function reset()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    imgElement.src = '';
    inputElement.value = '';
    points = [];
    
    document.getElementById("detectedText").textContent = "Text";
}


function processImage(imageData) {
    let img = new Image();
    img.onload = function() {
        let src = cv.imread(img);
        
        let threshold = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        let input_pts = new cv.Mat(4, 1, cv.CV_32FC2);
        let output_pts = new cv.Mat(4, 1, cv.CV_32FC2);

        window.input_pts.forEach((pt, i) => {
            input_pts.floatPtr(i)[0] = pt[0];
            input_pts.floatPtr(i)[1] = pt[1];
        });

        // Output points for new transformed image
        output_pts.floatPtr(0)[0] = 0;
        output_pts.floatPtr(0)[1] = 0;
        output_pts.floatPtr(1)[0] = 0;
        output_pts.floatPtr(1)[1] = window.max_width;
        output_pts.floatPtr(2)[0] = window.max_height;
        output_pts.floatPtr(2)[1] = 0;
        output_pts.floatPtr(3)[0] = window.max_height;
        output_pts.floatPtr(3)[1] = window.max_width;

        // Compute the perspective transform M
        let M = cv.getPerspectiveTransform(input_pts, output_pts);

        // Apply perspective transformation
        let dst = new cv.Mat();
        cv.warpPerspective(src, dst, M, new cv.Size(window.max_height, window.max_width), cv.INTER_LINEAR);

        // Convert to grayscale
        threshold = filter(dst);

        // Find contours
        cv.findContours(threshold, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

        // Initialize the output image
        let dst2 = new cv.Mat.zeros(dst.rows, dst.cols, cv.CV_8UC3);

        let extractedImages = [];
        let rectangles = [];

        // Combine and draw contours for larger areas
        let rectangleColor = new cv.Scalar(0, 255, 0);
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let rect = cv.boundingRect(cnt);
            if(rect.width !== src.cols && rect.height !== src.rows)
            {
             
            

            // Filter contours based on size to avoid small text areas
            if (rect.width > 500 && rect.height > 500) { // Adjust these thresholds as needed
                let point1 = new cv.Point(rect.x, rect.y);
                console.log(point1);
                let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                console.log(point2);
                rectangles.push({
                    x: rect.x,
                    y: rect.y,
                    height: rect.height,
                    width: rect.width
                });
                cv.rectangle(dst2, point1, point2, rectangleColor, 2, cv.LINE_AA, 0);
                let rotatedRect = cv.minAreaRect(cnt);
                    let box = cv.RotatedRect.points(rotatedRect);
                    for (let j = 0; j < 4; j++) {
                        let corner = new cv.Point(box[j].x, box[j].y);
                        cv.circle(dst2, corner, 5, new cv.Scalar(255, 0, 0), 2); // Draw the corners
                        console.log(`Corner ${j + 1}:`, box[j]);
                        points[j] = box[j];
                        
                    }
                    calculateDimensions(points);
                    // New Perspective Transformation
                    let perspectiveInput = cv.matFromArray(4, 1, cv.CV_32FC2, [
                        points[2].x, points[2].y,
                        points[1].x, points[1].y,
                        points[3].x, points[3].y,
                        points[0].x, points[0].y
                        
                    ]);
                    
                    let perspectiveOutput = new cv.Mat(4, 1, cv.CV_32FC2);
                    perspectiveOutput.floatPtr(0)[0] = 0;
                    perspectiveOutput.floatPtr(0)[1] = 0;
                    perspectiveOutput.floatPtr(1)[0] = 0;
                    perspectiveOutput.floatPtr(1)[1] = rect.height;
                    perspectiveOutput.floatPtr(2)[0] = rect.width;
                    perspectiveOutput.floatPtr(2)[1] = 0;
                    perspectiveOutput.floatPtr(3)[0] = rect.width;
                    perspectiveOutput.floatPtr(3)[1] = rect.height;

                    let newM = cv.getPerspectiveTransform(perspectiveInput, perspectiveOutput);
                    let warped = new cv.Mat();
                    cv.warpPerspective(dst, warped, newM, new cv.Size(rect.width, rect.height), cv.INTER_LINEAR);
                    let thresh = filter(warped);
                    cv.imshow('canvasOutput', thresh);
                    let dataURL = document.getElementById("canvasOutput").toDataURL("image/png");
                    performOCR(dataURL);

                    // Clean up
                    perspectiveInput.delete();
                    perspectiveOutput.delete();
                    newM.delete();
                    warped.delete();
            }
            }
        }

        let updatedExtractedImages = [];
        rectangles.forEach(rect => {
            let roi = dst.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
            updatedExtractedImages.push(roi);
        });

        cv.imshow('canvasoutputrect', dst2);

        
            
        


        // Clean up
        src.delete();
        threshold.delete();
        contours.delete();
        hierarchy.delete();
        dst.delete();
        dst2.delete();
        input_pts.delete();
        output_pts.delete();
        M.delete();
    };
    img.src = imageData;
}

function filter(input)
{
    let gray = new cv.Mat();
    let threshold = new cv.Mat();
    cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY, 0);

        // Apply binary thresholding
    cv.adaptiveThreshold(gray, threshold, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 13);
    return threshold;
}





function calculateDimensions(points) {
    if (points.length < 4) return;

    function distance(pt1, pt2) {
        return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));
    }

    let pt1 = points[0];
    let pt2 = points[1];
    let pt3 = points[2];
    let pt4 = points[3];

    let height_1 = distance(pt1, pt2);
    let height_2 = distance(pt3, pt4);
    let width_1 = distance(pt1, pt3);
    let width_2 = distance(pt2, pt4);

    let max_height = Math.max(height_1, height_2);
    let max_width = Math.max(width_1, width_2);

    window.max_height = Math.round(max_width);
    window.max_width = Math.round(max_height);
    window.input_pts = points.map(p => [p.x, p.y]);
}

function performOCR(imageData) {
    fetch(imageData)
        .then(res => res.arrayBuffer())
        .then(buffer => {
            const blob = new Blob([buffer]);
            console.log("loading");
            Tesseract.recognize(
                blob,
                'eng+tur', // Language
                {  
                    langPath: "./tessdata",
                    oem: 3, // OCR Engine Mode
                    psm: 6, // Page Segmentation Mode
                }
            ).then(({ data: { text } }) => {
                console.log('Detected text:', text);
                document.getElementById('detectedText').textContent = text
            }).catch(err => {
                console.error('OCR error:', err);
            });
        });
}
</script>
</body>
</html>
