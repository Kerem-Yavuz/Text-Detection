<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Text Detection and Recognition</title>
    <script async src="opencv.js" type="text/javascript"></script>
    <script src="tesseract.js"></script>
</head>
<body>
<h2>Text Detection and Recognition</h2>

<div>
    <img id="imageSrc" alt="No Image" style="display:none;" />
    <input type="file" id="fileInput" name="file" />
    <input type="button" onclick="reset()" value="reset">
    <canvas id="canvasOutput"></canvas>
    <canvas id="canvasoutputrect"></canvas>
    <button id="showRectanglesButton">Show Rectangles</button>
</div>
<p id = "detectedText" style="font-size: 20px;">Text</p>
<script type="text/javascript">
let imgElement = document.getElementById("imageSrc");
let inputElement = document.getElementById("fileInput");
let canvas = document.getElementById("canvasOutput");
let ctx = canvas.getContext('2d');
let points = [];
const maxPoints = 4;
let originalImageData = null; // To store the original image data for OpenCV processing

inputElement.addEventListener("change", (e) => {
    imgElement.src = URL.createObjectURL(e.target.files[0]);
    imgElement.onload = function() {
        // Set canvas dimensions and draw the original image
        canvas.width = imgElement.naturalWidth;
        canvas.height = imgElement.naturalHeight;
        ctx.drawImage(imgElement, 0, 0);

        // Store original image data for OpenCV processing
        originalImageData = canvas.toDataURL('image/png');
        
        // Clear points and add event listener for clicks
        points = [];
        canvas.addEventListener('click', onCanvasClick);
    };
}, false);
function reset()
{
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    imgElement.src = '';
    inputElement.value = '';
    points = [];
    canvas.removeEventListener('click', onCanvasClick);
    document.getElementById("detectedText").textContent = "Text";
}
function onCanvasClick(event) {
    if (points.length >= maxPoints) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    points.push({ x, y });
    console.log(`Point ${points.length}: (${x}, ${y})`);

    // Draw the point on the canvas
    ctx.beginPath();
    ctx.arc(x, y, 5, 0, 2 * Math.PI);
    ctx.fillStyle = 'red';
    ctx.fill();

    if (points.length === maxPoints) {
        console.log('All points:', points);
        canvas.removeEventListener('click', onCanvasClick);
        calculateDimensions(points);
        // Process the original image with OpenCV
        processImage(originalImageData);
    }
}

function processImage(imageData) {
    let img = new Image();
    img.onload = function() {
        let src = cv.imread(img);
        let threshold = new cv.Mat();
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();

        let input_pts = new cv.Mat(4, 1, cv.CV_32FC2);
        let output_pts = new cv.Mat(4, 1, cv.CV_32FC2);

        window.input_pts.forEach((pt, i) => {
            input_pts.floatPtr(i)[0] = pt[0];
            input_pts.floatPtr(i)[1] = pt[1];
        });

        // Output points for new transformed image
        output_pts.floatPtr(0)[0] = 0;
        output_pts.floatPtr(0)[1] = 0;
        output_pts.floatPtr(1)[0] = 0;
        output_pts.floatPtr(1)[1] = window.max_width;
        output_pts.floatPtr(2)[0] = window.max_height;
        output_pts.floatPtr(2)[1] = 0;
        output_pts.floatPtr(3)[0] = window.max_height;
        output_pts.floatPtr(3)[1] = window.max_width;

        // Compute the perspective transform M
        let M = cv.getPerspectiveTransform(input_pts, output_pts);

        // Apply perspective transformation
        let dst = new cv.Mat();
        cv.warpPerspective(src, dst, M, new cv.Size(window.max_height, window.max_width), cv.INTER_LINEAR);

        // Convert to grayscale
        threshold = filter(dst);

        // Find contours
        cv.findContours(threshold, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

        // Initialize the output image
        let dst2 = new cv.Mat.zeros(dst.rows, dst.cols, cv.CV_8UC3);

        let extractedImages = [];
        let rectangles = [];

        // Combine and draw contours for larger areas
        let rectangleColor = new cv.Scalar(0, 255, 0);
        for (let i = 0; i < contours.size(); ++i) {
            let cnt = contours.get(i);
            let rect = cv.boundingRect(cnt);

            // Filter contours based on size to avoid small text areas
            if (rect.width > 5 && rect.height > 5) { // Adjust these thresholds as needed
                let point1 = new cv.Point(rect.x, rect.y);
                let point2 = new cv.Point(rect.x + rect.width, rect.y + rect.height);
                
                rectangles.push({
                    x: rect.x,
                    y: rect.y,
                    height: rect.height,
                    width: rect.width
                });
                cv.rectangle(dst2, point1, point2, rectangleColor, 2, cv.LINE_AA, 0);
            }
        }

        // Function to check if two rectangles overlap or are close
        function areRectanglesClose(r1, r2, thresholdX, thresholdY) {
            let dx = Math.max(r1.x, r2.x) - Math.min(r1.x + r1.width, r2.x + r2.width);
            let dy = Math.max(r1.y, r2.y) - Math.min(r1.y + r1.height, r2.y + r2.height);
            return dx < thresholdX && dy < thresholdY;
        }

        // Function to merge two rectangles
        function mergeRectangles(r1, r2) {
            let left = Math.min(r1.x, r2.x);
            let top = Math.min(r1.y, r2.y);
            let right = Math.max(r1.x + r1.width, r2.x + r2.width);
            let bottom = Math.max(r1.y + r1.height, r2.y + r2.height);

            return {
                x: left,
                y: top,
                width: right - left,
                height: bottom - top
            };
        }

        // Merge overlapping or close rectangles and fill merged areas with white rectangles
        function mergeAllRectangles(rects, closeThresholdX, closeThresholdY) {
            let merged = [];
            while (rects.length > 0) {
                let current = rects.shift();
                let toMerge = [current];
                for (let i = rects.length - 1; i >= 0; i--) {
                    if (areRectanglesClose(current, rects[i], closeThresholdX, closeThresholdY)) {
                        toMerge.push(rects.splice(i, 1)[0]);
                    }
                }
                if (toMerge.length > 0) {
                    let mergedRect = toMerge.reduce((acc, rect) => mergeRectangles(acc, rect));
                    merged.push(mergedRect);
                    
                    // Draw white rectangle in the merged area
                    let point1 = new cv.Point(mergedRect.x, mergedRect.y);
                    let point2 = new cv.Point(mergedRect.x + mergedRect.width, mergedRect.y + mergedRect.height);
                    cv.rectangle(dst2, point1, point2, new cv.Scalar(255, 255, 255), -1);
                }
            }
            return merged;
        }

        // Define a threshold distance for merging close rectangles
        const closeThresholdX = 20; // Adjust this value as needed
        const closeThresholdY = 5; // Adjust this value as needed

        // Update rectangles with merged results
        rectangles = mergeAllRectangles(rectangles, closeThresholdX, closeThresholdY);

        // Extract the regions based on merged rectangles
        let updatedExtractedImages = [];
        rectangles.forEach(rect => {
            let roi = dst.roi(new cv.Rect(rect.x, rect.y, rect.width, rect.height));
            updatedExtractedImages.push(roi);
        });

        console.log(updatedExtractedImages);
        console.log(rectangles);

        // Show result
        cv.imshow('canvasOutput', threshold);
        cv.imshow('canvasoutputrect', dst2);

        updatedExtractedImages.forEach((image, i) => {
            // Create a unique canvas ID for each image
            let canvasId = `canvasoutput${i}`;

            // Create a new canvas element
            let canvas2 = document.createElement('canvas');
            canvas2.id = canvasId;
            canvas2.width = image.cols;
            canvas2.height = image.rows;
            if (image.rows === window.max_width && image.cols === window.max_height) {
                return; // we want smaller part so it will not look to the whole image
            }
            document.body.appendChild(canvas2); // Append the canvas to the body (or any container you prefer)

            threshold = filter(image);

            // Display the image on the canvas
            cv.imshow(canvasId, threshold);

            // Convert canvas to data URL
            let canvasElement = document.getElementById(canvasId);
            let dataURL = canvasElement.toDataURL('image/png');

            // Perform OCR with the data URL
            // performOCR(dataURL);
        });

        // Clean up
        src.delete();
        threshold.delete();
        contours.delete();
        hierarchy.delete();
        dst.delete();
        dst2.delete();
        input_pts.delete();
        output_pts.delete();
        M.delete();
    };
    img.src = imageData;
}


function filter(input)
{
    let gray = new cv.Mat();
    let threshold = new cv.Mat();
    cv.cvtColor(input, gray, cv.COLOR_RGB2GRAY, 0);

        // Apply binary thresholding
    cv.adaptiveThreshold(gray, threshold, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 21, 7);
    return threshold;
}




function calculateDimensions(points) {
    if (points.length < 4) return;

    function distance(pt1, pt2) {
        return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));
    }

    let pt1 = points[0];
    let pt2 = points[1];
    let pt3 = points[2];
    let pt4 = points[3];

    let height_1 = distance(pt1, pt2);
    let height_2 = distance(pt3, pt4);
    let width_1 = distance(pt1, pt3);
    let width_2 = distance(pt2, pt4);

    let max_height = Math.max(height_1, height_2);
    let max_width = Math.max(width_1, width_2);

    console.log(`Max Height: ${Math.round(max_height)}`);
    console.log(`Max Width: ${Math.round(max_width)}`);

    window.max_height = Math.round(max_width);
    window.max_width = Math.round(max_height);
    window.input_pts = points.map(p => [p.x, p.y]);
}

function performOCR(imageData) {
    fetch(imageData)
        .then(res => res.arrayBuffer())
        .then(buffer => {
            const blob = new Blob([buffer]);

            Tesseract.recognize(
                blob,
                'tur', // Language
                {  
                    langPath: "./tessdata",
                    oem: 3, // OCR Engine Mode
                    psm: 6, // Page Segmentation Mode
                }
            ).then(({ data: { text } }) => {
                console.log('Detected text:', text);
                document.getElementById('detectedText').textContent = text
            }).catch(err => {
                console.error('OCR error:', err);
            });
        });
}
</script>
</body>
</html>
